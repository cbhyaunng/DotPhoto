<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dot Photo Studio</title>
  <style>
    :root {
      --bg: #f4efe8;
      --panel: #fff8ee;
      --text: #2a1f14;
      --muted: #695038;
      --line: #decdb8;
      --accent: #d86f1a;
      --accent-2: #ffb366;
      --accent-3: #138f8a;
      --canvas: #11161d;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "SUIT", "Pretendard", "Noto Sans KR", "Apple SD Gothic Neo", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 500px at -20% -10%, #ffe6c3 0%, transparent 55%),
        radial-gradient(800px 400px at 120% 110%, #c9f0e9 0%, transparent 60%),
        var(--bg);
      padding: 20px;
    }

    .shell {
      max-width: 1120px;
      margin: 0 auto;
      display: grid;
      gap: 14px;
    }

    .hero {
      border: 1px solid var(--line);
      background: linear-gradient(160deg, #fff7ea, #fff1e0);
      border-radius: 18px;
      padding: 20px;
      box-shadow: 0 10px 28px rgba(68, 38, 7, 0.08);
    }

    .hero-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 14px;
      flex-wrap: wrap;
    }

    .hero h1 {
      margin: 0;
      font-size: clamp(1.4rem, 2.5vw, 2.1rem);
      letter-spacing: -0.02em;
    }

    .hero p {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .hero-nav {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .hero-nav a {
      display: inline-flex;
      align-items: center;
      padding: 7px 11px;
      border-radius: 999px;
      border: 1px solid #debc9b;
      background: #fff5e9;
      color: #6b421c;
      text-decoration: none;
      font-size: 0.82rem;
      font-weight: 700;
      transition: background 0.15s ease, border-color 0.15s ease;
    }

    .hero-nav a:hover {
      background: #ffedd9;
      border-color: #d89e69;
    }

    .grid {
      display: grid;
      grid-template-columns: 340px 1fr;
      gap: 14px;
    }

    .panel {
      border: 1px solid var(--line);
      background: var(--panel);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 10px 24px rgba(55, 30, 4, 0.06);
    }

    .panel h2 {
      margin: 0 0 12px;
      font-size: 1rem;
    }

    .dropzone {
      display: grid;
      justify-items: center;
      align-content: center;
      gap: 6px;
      width: 100%;
      min-height: 132px;
      border: 2px dashed #d9b992;
      border-radius: 14px;
      padding: 18px 14px;
      text-align: center;
      background: #fff;
      transition: 0.2s ease;
      cursor: pointer;
    }

    .dropzone.dragging {
      border-color: var(--accent);
      background: #fff3e6;
      transform: translateY(-1px);
    }

    .dropzone .dropzone-icon {
      width: 36px;
      height: 36px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-size: 1.15rem;
      font-weight: 800;
      color: #9a520e;
      background: #ffe9d2;
      border: 1px solid #f3cba5;
      line-height: 1;
    }

    .dropzone strong {
      color: #6f4010;
      display: block;
      margin: 0;
      line-height: 1.35;
    }

    .dropzone span {
      color: #7d6043;
      font-size: 0.88rem;
      line-height: 1.3;
    }

    .dropzone .dropzone-help {
      padding: 2px 10px;
      border-radius: 999px;
      background: #fff4e6;
      border: 1px solid #f0d6b6;
    }

    input[type="file"] {
      display: none;
    }

    .controls {
      margin-top: 12px;
      display: grid;
      gap: 10px;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.88rem;
      color: #5d452e;
      font-weight: 600;
    }

    .value-tag {
      display: inline-block;
      min-width: 58px;
      text-align: center;
      padding: 2px 8px;
      border-radius: 999px;
      background: #fff0dc;
      color: #8f4a0a;
      font-weight: 700;
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
      cursor: pointer;
    }

    select {
      width: 100%;
      border: 1px solid #d6bfa3;
      border-radius: 10px;
      padding: 10px 12px;
      background: #fff;
      color: var(--text);
      font: inherit;
      font-size: 0.93rem;
    }

    .label-inline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      position: relative;
    }

    .label-inline label {
      margin: 0;
      font-size: 0.88rem;
      color: #5d452e;
      font-weight: 600;
    }

    .info-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .info-btn {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid #caa57f;
      background: #fff4e7;
      color: #7f4a13;
      font-size: 0.72rem;
      font-weight: 800;
      line-height: 1;
      display: inline-grid;
      place-items: center;
      padding: 0;
      cursor: pointer;
    }

    .info-tooltip {
      position: absolute;
      right: 0;
      top: calc(100% + 8px);
      width: min(320px, calc(100vw - 70px));
      z-index: 20;
      background: #fff9f1;
      border: 1px solid #d9b992;
      border-radius: 10px;
      box-shadow: 0 10px 20px rgba(58, 35, 12, 0.12);
      padding: 9px 10px;
      font-size: 0.79rem;
      line-height: 1.4;
      color: #5f4428;
      opacity: 0;
      visibility: hidden;
      transform: translateY(4px);
      transition: opacity 0.15s ease, transform 0.15s ease, visibility 0.15s ease;
    }

    .info-wrap:hover .info-tooltip,
    .info-wrap:focus-within .info-tooltip,
    .info-wrap.open .info-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.86rem;
      color: #5d452e;
      padding: 9px 10px;
      border: 1px solid #dcc8b0;
      border-radius: 10px;
      background: #fff;
    }

    .toggle-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
      margin: 0;
      cursor: pointer;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 12px;
    }

    button {
      border: 0;
      border-radius: 12px;
      padding: 11px 12px;
      font: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.15s ease, filter 0.15s ease;
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.02);
    }

    .primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #fff;
    }

    .secondary {
      background: linear-gradient(135deg, #1f8a84, #56c6bf);
      color: #fff;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      filter: none;
    }

    .status {
      margin-top: 10px;
      min-height: 20px;
      font-size: 0.88rem;
      color: #6b4f33;
    }

    .result-card {
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: 560px;
    }

    .result-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
    }

    .result-head p {
      margin: 0;
      color: #6d5339;
      font-size: 0.88rem;
    }

    .canvas-wrap {
      border: 1px solid #2b3340;
      background:
        linear-gradient(45deg, #19212a 25%, #1f2933 25%, #1f2933 50%, #19212a 50%, #19212a 75%, #1f2933 75%, #1f2933 100%);
      background-size: 20px 20px;
      border-radius: 14px;
      padding: 12px;
      overflow: auto;
      display: grid;
      place-items: center;
    }

    .canvas-stage {
      position: relative;
      display: inline-grid;
      overflow: hidden;
      border-radius: 6px;
    }

    .compare-panel {
      margin-bottom: 10px;
      padding: 8px 10px;
      border: 1px solid #e4d3bd;
      border-radius: 10px;
      background: #fffaf2;
    }

    .compare-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 0.84rem;
      color: #664a2f;
      font-weight: 600;
    }

    .compare-row .value-tag {
      min-width: 62px;
      padding: 1px 8px;
      font-size: 0.78rem;
    }

    .compare-divider {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.45);
      pointer-events: none;
      transform: translateX(-1px);
      z-index: 5;
    }

    .compare-divider::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: #fff;
      border: 2px solid #111;
      transform: translate(-50%, -50%);
    }

    .compare-tag {
      position: absolute;
      top: 8px;
      z-index: 6;
      font-size: 0.72rem;
      font-weight: 700;
      padding: 4px 6px;
      border-radius: 999px;
      letter-spacing: 0.02em;
      pointer-events: none;
      user-select: none;
    }

    .compare-tag.before {
      left: 8px;
      background: rgba(17, 17, 17, 0.65);
      color: #fff;
    }

    .compare-tag.after {
      right: 8px;
      background: rgba(255, 255, 255, 0.92);
      color: #1c1c1c;
      border: 1px solid rgba(0, 0, 0, 0.22);
    }

    canvas {
      max-width: 100%;
      height: auto;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border-radius: 6px;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06);
      background: var(--canvas);
      cursor: crosshair;
    }

    .canvas-stage canvas {
      grid-area: 1 / 1;
    }

    #selectionCanvas {
      background: transparent;
      box-shadow: none;
      pointer-events: none;
      cursor: default;
    }

    .meta {
      margin-top: 10px;
      font-size: 0.85rem;
      color: #806145;
    }

    .palette {
      margin-top: 12px;
      border: 1px solid #e4d3bd;
      border-radius: 12px;
      background: #fff;
      padding: 10px;
    }

    .palette-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .palette-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .palette-head strong {
      font-size: 0.9rem;
      color: #5f4429;
    }

    .palette-head span {
      font-size: 0.82rem;
      color: #826142;
    }

    .palette-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(116px, 1fr));
      gap: 8px;
      max-height: 190px;
      overflow: auto;
      padding-right: 3px;
    }

    .swatch-item {
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 36px;
      border: 1px solid #eadbca;
      border-radius: 10px;
      padding: 6px 8px;
      background: #fffaf4;
      transition: 0.15s ease;
      cursor: pointer;
    }

    .swatch-item:hover {
      border-color: #dfc5a6;
      background: #fff4e8;
    }

    .swatch-item.active {
      border-color: #d86f1a;
      background: #fff0de;
      box-shadow: 0 0 0 2px rgba(216, 111, 26, 0.18);
    }

    .swatch-color {
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid rgba(0, 0, 0, 0.15);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.24);
      flex: 0 0 auto;
    }

    .swatch-code {
      font-size: 0.82rem;
      color: #5e462c;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .palette-empty {
      font-size: 0.84rem;
      color: #7a5a3c;
      padding: 4px 2px;
    }

    .site-footer {
      border: 1px solid var(--line);
      background: #fff9f1;
      border-radius: 16px;
      padding: 14px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      color: #6c4e33;
      font-size: 0.84rem;
    }

    .footer-links {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .footer-links a {
      text-decoration: none;
      color: #73461f;
      background: #fff2df;
      border: 1px solid #e4c7a8;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 700;
      font-size: 0.8rem;
    }

    .footer-links a:hover {
      background: #ffe8cc;
      border-color: #d8ab7c;
    }

    @media (max-width: 920px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .result-card {
        min-height: 460px;
      }
    }
  </style>
</head>
<body>
  <main class="shell">
    <section class="hero">
      <div class="hero-top">
        <div>
          <h1>Dot Photo Studio</h1>
          <p id="heroSubtitle">사진을 올리면 브라우저에서 바로 도트 이미지로 변환합니다. 서버 업로드 없이 로컬에서 처리됩니다.</p>
        </div>
        <nav class="hero-nav" aria-label="사이트 문서 링크">
          <a id="heroLinkAbout" href="about.html">서비스 소개</a>
          <a id="heroLinkPrivacy" href="privacy.html">개인정보처리방침</a>
          <a id="heroLinkTerms" href="terms.html">이용약관</a>
          <a id="heroLinkContact" href="contact.html">문의하기</a>
          <a id="heroLinkSitemap" href="sitemap.html">사이트맵</a>
        </nav>
      </div>
    </section>

    <section class="grid">
      <aside class="panel">
        <h2 id="settingsTitle">변환 설정</h2>

        <label class="dropzone" id="dropzone" for="fileInput">
          <span class="dropzone-icon" aria-hidden="true">+</span>
          <strong id="dropzoneLabel">사진 파일 선택 또는 드래그</strong>
          <span class="dropzone-help" id="dropzoneHelp">JPG, PNG, WEBP 지원</span>
        </label>
        <input id="fileInput" type="file" accept="image/*" />

        <div class="controls">
          <div class="field">
            <label for="languageSelect" id="languageLabel">언어</label>
            <select id="languageSelect">
              <option value="ko" selected>한국어</option>
              <option value="en">English</option>
            </select>
          </div>

          <div class="field">
            <label for="dotSize">
              <span id="dotSizeLabelText">도트 크기</span>
              <span class="value-tag" id="dotSizeValue">10px</span>
            </label>
            <input id="dotSize" type="range" min="1" max="30" step="1" value="10" />
          </div>

          <div class="field">
            <label for="colorLevels">
              <span id="colorLevelsLabelText">색상 단계</span>
              <span class="value-tag" id="colorLevelsValue">6단계</span>
            </label>
            <input id="colorLevels" type="range" min="2" max="16" step="1" value="6" />
          </div>

          <div class="field">
            <label for="outputWidth">
              <span id="outputWidthLabelText">출력 폭</span>
              <span class="value-tag" id="outputWidthValue">720px</span>
            </label>
            <input id="outputWidth" type="range" min="320" max="1400" step="20" value="720" />
          </div>

          <div class="field">
            <label for="dotShape" id="dotShapeLabel">도트 모양</label>
            <select id="dotShape">
              <option value="circle">원형 도트</option>
              <option value="square" selected>사각 도트</option>
            </select>
          </div>

          <div class="field">
            <div class="label-inline">
              <label for="ditherMode" id="ditherLabel">디더링</label>
              <span class="info-wrap" id="ditherInfoWrap">
                <button class="info-btn" type="button" id="ditherInfoBtn" aria-label="디더링 옵션 설명 보기" aria-expanded="false">i</button>
                <span class="info-tooltip" role="tooltip" id="ditherInfoTooltip">
                  없음: 가장 빠르지만 계단 현상이 있을 수 있습니다.<br />
                  Ordered: 속도와 품질의 균형이 좋습니다.<br />
                  Floyd-Steinberg: 가장 자연스럽지만 변환이 느릴 수 있습니다.
                </span>
              </span>
            </div>
            <select id="ditherMode">
              <option value="none" selected>없음 (빠름)</option>
              <option value="ordered">Ordered (균형)</option>
              <option value="floyd">Floyd-Steinberg (고품질)</option>
            </select>
          </div>

          <div class="field">
            <label for="fastModeToggle" id="fastModeLabel">고속 모드</label>
            <label class="toggle-row" for="fastModeToggle">
              <input id="fastModeToggle" type="checkbox" checked />
              <span id="fastModeDesc">저픽셀(1~2px)에서 자동 최적화</span>
            </label>
          </div>
        </div>

        <div class="row">
          <button class="primary" id="convertButton" type="button" disabled>도트 변환</button>
          <button class="secondary" id="downloadButton" type="button" disabled>PNG 다운로드</button>
        </div>

        <div class="status" id="statusText">이미지를 먼저 선택해 주세요.</div>
      </aside>

      <section class="panel result-card">
        <div>
          <div class="result-head">
            <h2 id="resultTitle">결과 미리보기</h2>
            <p id="dotInfo">-</p>
          </div>
          <div class="compare-panel">
            <div class="compare-row">
              <span id="compareLabel">Before / After 비교</span>
              <span class="value-tag" id="compareValue">100%</span>
            </div>
            <input id="compareSlider" type="range" min="0" max="100" step="1" value="100" />
          </div>
        </div>
        <div class="canvas-wrap">
          <div class="canvas-stage">
            <canvas id="originalCanvas" width="720" height="480"></canvas>
            <canvas id="resultCanvas" width="720" height="480"></canvas>
            <canvas id="selectionCanvas" width="720" height="480"></canvas>
            <div class="compare-divider" id="compareDivider"></div>
            <div class="compare-tag before" id="compareTagBefore">원본</div>
            <div class="compare-tag after" id="compareTagAfter">도트</div>
          </div>
        </div>
        <div class="palette">
          <div class="palette-head">
            <strong id="paletteTitle">도트 색상 코드</strong>
            <div class="palette-meta">
              <span id="pickedColor">선택: -</span>
              <span id="paletteCount">0 colors</span>
            </div>
          </div>
          <div class="palette-grid" id="paletteGrid">
            <div class="palette-empty">변환하면 색상 코드가 표시됩니다.</div>
          </div>
        </div>
        <div class="meta" id="tipText">팁: 비교 슬라이더로 원본/도트를 나눠보고, 도트를 클릭하면 해당 색상이 팔레트에서 하이라이트됩니다.</div>
      </section>
    </section>

    <footer class="site-footer">
      <span id="footerSummary">서비스 문서: 사이트 소개, 정책, 문의 페이지를 확인할 수 있습니다.</span>
      <nav class="footer-links" aria-label="문서 링크">
        <a id="footerLinkAbout" href="about.html">소개</a>
        <a id="footerLinkPrivacy" href="privacy.html">개인정보처리방침</a>
        <a id="footerLinkTerms" href="terms.html">이용약관</a>
        <a id="footerLinkContact" href="contact.html">문의</a>
        <a id="footerLinkSitemap" href="sitemap.html">사이트맵</a>
      </nav>
    </footer>
  </main>

  <script>
    const fileInput = document.getElementById("fileInput");
    const dropzone = document.getElementById("dropzone");
    const convertButton = document.getElementById("convertButton");
    const downloadButton = document.getElementById("downloadButton");
    const statusText = document.getElementById("statusText");
    const dotInfo = document.getElementById("dotInfo");
    const paletteGrid = document.getElementById("paletteGrid");
    const paletteCount = document.getElementById("paletteCount");
    const pickedColor = document.getElementById("pickedColor");

    const dotSize = document.getElementById("dotSize");
    const colorLevels = document.getElementById("colorLevels");
    const outputWidth = document.getElementById("outputWidth");
    const languageSelect = document.getElementById("languageSelect");
    const dotShape = document.getElementById("dotShape");
    const ditherMode = document.getElementById("ditherMode");
    const ditherInfoWrap = document.getElementById("ditherInfoWrap");
    const ditherInfoBtn = document.getElementById("ditherInfoBtn");
    const ditherInfoTooltip = document.getElementById("ditherInfoTooltip");
    const fastModeToggle = document.getElementById("fastModeToggle");
    const compareSlider = document.getElementById("compareSlider");
    const compareValue = document.getElementById("compareValue");
    const compareDivider = document.getElementById("compareDivider");

    const heroSubtitle = document.getElementById("heroSubtitle");
    const heroLinkAbout = document.getElementById("heroLinkAbout");
    const heroLinkPrivacy = document.getElementById("heroLinkPrivacy");
    const heroLinkTerms = document.getElementById("heroLinkTerms");
    const heroLinkContact = document.getElementById("heroLinkContact");
    const heroLinkSitemap = document.getElementById("heroLinkSitemap");
    const settingsTitle = document.getElementById("settingsTitle");
    const dropzoneLabel = document.getElementById("dropzoneLabel");
    const dropzoneHelp = document.getElementById("dropzoneHelp");
    const languageLabel = document.getElementById("languageLabel");
    const dotSizeLabelText = document.getElementById("dotSizeLabelText");
    const colorLevelsLabelText = document.getElementById("colorLevelsLabelText");
    const outputWidthLabelText = document.getElementById("outputWidthLabelText");
    const dotShapeLabel = document.getElementById("dotShapeLabel");
    const ditherLabel = document.getElementById("ditherLabel");
    const fastModeLabel = document.getElementById("fastModeLabel");
    const fastModeDesc = document.getElementById("fastModeDesc");
    const resultTitle = document.getElementById("resultTitle");
    const compareLabel = document.getElementById("compareLabel");
    const compareTagBefore = document.getElementById("compareTagBefore");
    const compareTagAfter = document.getElementById("compareTagAfter");
    const paletteTitle = document.getElementById("paletteTitle");
    const tipText = document.getElementById("tipText");
    const footerSummary = document.getElementById("footerSummary");
    const footerLinkAbout = document.getElementById("footerLinkAbout");
    const footerLinkPrivacy = document.getElementById("footerLinkPrivacy");
    const footerLinkTerms = document.getElementById("footerLinkTerms");
    const footerLinkContact = document.getElementById("footerLinkContact");
    const footerLinkSitemap = document.getElementById("footerLinkSitemap");

    const dotSizeValue = document.getElementById("dotSizeValue");
    const colorLevelsValue = document.getElementById("colorLevelsValue");
    const outputWidthValue = document.getElementById("outputWidthValue");

    const originalCanvas = document.getElementById("originalCanvas");
    const originalCtx = originalCanvas.getContext("2d");
    const resultCanvas = document.getElementById("resultCanvas");
    const resultCtx = resultCanvas.getContext("2d");
    const selectionCanvas = document.getElementById("selectionCanvas");
    const selectionCtx = selectionCanvas.getContext("2d");
    const sampleCanvas = document.createElement("canvas");
    const sampleCtx = sampleCanvas.getContext("2d", { willReadFrequently: true });

    const state = {
      image: null,
      fileName: "dot-photo",
      dotHexGrid: [],
      dotCols: 0,
      dotRows: 0,
      dotCellSize: 0,
      dotShape: "square",
      dotRadius: 0,
      selectedDot: null,
      renderTimer: null,
      language: "ko",
      paletteColorCount: 0,
    };

    const I18N = {
      ko: {
        pageTitle: "Dot Photo Studio",
        heroSubtitle: "사진을 올리면 브라우저에서 바로 도트 이미지로 변환합니다. 서버 업로드 없이 로컬에서 처리됩니다.",
        heroLinkAbout: "서비스 소개",
        heroLinkPrivacy: "개인정보처리방침",
        heroLinkTerms: "이용약관",
        heroLinkContact: "문의하기",
        heroLinkSitemap: "사이트맵",
        settingsTitle: "변환 설정",
        dropzoneLabel: "사진 파일 선택 또는 드래그",
        dropzoneHelp: "JPG, PNG, WEBP 지원",
        languageLabel: "언어",
        languageOptionKo: "한국어",
        languageOptionEn: "English",
        dotSizeLabel: "도트 크기",
        colorLevelsLabel: "색상 단계",
        colorLevelsUnit: "단계",
        outputWidthLabel: "출력 폭",
        dotShapeLabel: "도트 모양",
        dotShapeCircle: "원형 도트",
        dotShapeSquare: "사각 도트",
        ditherLabel: "디더링",
        ditherInfoAria: "디더링 옵션 설명 보기",
        ditherTooltipNone: "없음: 가장 빠르지만 계단 현상이 있을 수 있습니다.",
        ditherTooltipOrdered: "Ordered: 속도와 품질의 균형이 좋습니다.",
        ditherTooltipFloyd: "Floyd-Steinberg: 가장 자연스럽지만 변환이 느릴 수 있습니다.",
        ditherOptionNone: "없음 (빠름)",
        ditherOptionOrdered: "Ordered (균형)",
        ditherOptionFloyd: "Floyd-Steinberg (고품질)",
        fastModeLabel: "고속 모드",
        fastModeDesc: "저픽셀(1~2px)에서 자동 최적화",
        convertButton: "도트 변환",
        downloadButton: "PNG 다운로드",
        resultTitle: "결과 미리보기",
        compareLabel: "Before / After 비교",
        compareTagBefore: "원본",
        compareTagAfter: "도트",
        paletteTitle: "도트 색상 코드",
        pickedPrefix: "선택",
        paletteColorsUnit: "colors",
        paletteEmptyBefore: "변환하면 색상 코드가 표시됩니다.",
        paletteEmptyNone: "감지된 색상이 없습니다.",
        tipText: "팁: 비교 슬라이더로 원본/도트를 나눠보고, 도트를 클릭하면 해당 색상이 팔레트에서 하이라이트됩니다.",
        footerSummary: "서비스 문서: 사이트 소개, 정책, 문의 페이지를 확인할 수 있습니다.",
        footerLinkAbout: "소개",
        footerLinkPrivacy: "개인정보처리방침",
        footerLinkTerms: "이용약관",
        footerLinkContact: "문의",
        footerLinkSitemap: "사이트맵",
        statusSelectFirst: "이미지를 먼저 선택해 주세요.",
        statusClickAfter: "도트(After) 영역을 클릭해 주세요.",
        statusClickCircle: "원형 도트 내부를 클릭해 주세요.",
        statusNoColor: "해당 위치의 색상 정보를 찾을 수 없습니다.",
        statusSelectedDot: "선택된 도트 색상: {hex}",
        statusSelectedPalette: "선택된 팔레트 색상: {hex}",
        statusLoadDone: "{name} 로드 완료",
        statusImageReadError: "이미지를 읽을 수 없습니다. 다른 파일을 선택해 주세요.",
        statusFileReadError: "파일을 읽는 중 오류가 발생했습니다.",
        statusImageOnly: "이미지 파일만 업로드할 수 있습니다.",
        statusComplete: "도트 변환이 완료되었습니다.",
        statusCompleteWithNotices: "도트 변환 완료 ({notices})",
        noticeCircleFallback: "1~2px 원형은 사각 도트로 자동 변환",
        noticeFastPrefix: "고속 모드",
        noticeWidthCap: "출력 폭 {width}px로 제한",
        noticeDitherDowngrade: "디더링을 Ordered로 변경",
        dotInfoFormat: "{cols} x {rows} dots · {dither} dither",
        ditherNameNone: "none",
        ditherNameOrdered: "ordered",
        ditherNameFloyd: "floyd",
        canvasMessageSelect: "이미지를 선택해 주세요",
        canvasMessageInit: "이미지를 선택하면 결과가 표시됩니다",
      },
      en: {
        pageTitle: "Dot Photo Studio",
        heroSubtitle: "Upload a photo and convert it into dot art directly in your browser. Everything is processed locally without server upload.",
        heroLinkAbout: "About",
        heroLinkPrivacy: "Privacy Policy",
        heroLinkTerms: "Terms",
        heroLinkContact: "Contact",
        heroLinkSitemap: "Sitemap",
        settingsTitle: "Conversion Settings",
        dropzoneLabel: "Choose a photo or drag and drop",
        dropzoneHelp: "Supports JPG, PNG, WEBP",
        languageLabel: "Language",
        languageOptionKo: "Korean",
        languageOptionEn: "English",
        dotSizeLabel: "Dot Size",
        colorLevelsLabel: "Color Levels",
        colorLevelsUnit: "levels",
        outputWidthLabel: "Output Width",
        dotShapeLabel: "Dot Shape",
        dotShapeCircle: "Circle Dots",
        dotShapeSquare: "Square Dots",
        ditherLabel: "Dithering",
        ditherInfoAria: "Show dithering options info",
        ditherTooltipNone: "None: fastest, but can show color banding.",
        ditherTooltipOrdered: "Ordered: balanced speed and quality.",
        ditherTooltipFloyd: "Floyd-Steinberg: best quality, but slower.",
        ditherOptionNone: "None (Fast)",
        ditherOptionOrdered: "Ordered (Balanced)",
        ditherOptionFloyd: "Floyd-Steinberg (High Quality)",
        fastModeLabel: "Fast Mode",
        fastModeDesc: "Auto-optimization at low pixel size (1-2px)",
        convertButton: "Convert to Dots",
        downloadButton: "Download PNG",
        resultTitle: "Preview",
        compareLabel: "Before / After",
        compareTagBefore: "Before",
        compareTagAfter: "After",
        paletteTitle: "Dot Color Codes",
        pickedPrefix: "Selected",
        paletteColorsUnit: "colors",
        paletteEmptyBefore: "Color codes will appear after conversion.",
        paletteEmptyNone: "No colors detected.",
        tipText: "Tip: Use the compare slider to inspect before/after, then click a dot to highlight its color in the palette.",
        footerSummary: "Site documents: overview, policies, and contact pages are available.",
        footerLinkAbout: "About",
        footerLinkPrivacy: "Privacy",
        footerLinkTerms: "Terms",
        footerLinkContact: "Contact",
        footerLinkSitemap: "Sitemap",
        statusSelectFirst: "Please choose an image first.",
        statusClickAfter: "Please click in the After area.",
        statusClickCircle: "Please click inside a circle dot.",
        statusNoColor: "No color data found at that position.",
        statusSelectedDot: "Selected dot color: {hex}",
        statusSelectedPalette: "Selected palette color: {hex}",
        statusLoadDone: "{name} loaded",
        statusImageReadError: "Cannot read this image. Please choose another file.",
        statusFileReadError: "An error occurred while reading the file.",
        statusImageOnly: "Only image files can be uploaded.",
        statusComplete: "Dot conversion completed.",
        statusCompleteWithNotices: "Dot conversion completed ({notices})",
        noticeCircleFallback: "Circle mode at 1-2px is auto-converted to square dots",
        noticeFastPrefix: "Fast mode",
        noticeWidthCap: "Output width limited to {width}px",
        noticeDitherDowngrade: "Dithering switched to Ordered",
        dotInfoFormat: "{cols} x {rows} dots · {dither} dithering",
        ditherNameNone: "none",
        ditherNameOrdered: "ordered",
        ditherNameFloyd: "floyd",
        canvasMessageSelect: "Please select an image",
        canvasMessageInit: "Result will appear after you select an image",
      },
    };

    function normalizeLanguage(language) {
      return language === "en" ? "en" : "ko";
    }

    function getLanguageFromUrl() {
      const language = new URLSearchParams(window.location.search).get("lang");
      if (!language) return null;
      return normalizeLanguage(language);
    }

    function updateLanguageQuery() {
      const url = new URL(window.location.href);
      if (state.language === "en") {
        url.searchParams.set("lang", "en");
      } else {
        url.searchParams.delete("lang");
      }
      window.history.replaceState(null, "", url.toString());
    }

    function localPage(name) {
      return state.language === "en" ? `${name}-en.html` : `${name}.html`;
    }

    function applyLocalizedDocLinks() {
      heroLinkAbout.href = localPage("about");
      heroLinkPrivacy.href = localPage("privacy");
      heroLinkTerms.href = localPage("terms");
      heroLinkContact.href = localPage("contact");
      heroLinkSitemap.href = localPage("sitemap");
      footerLinkAbout.href = localPage("about");
      footerLinkPrivacy.href = localPage("privacy");
      footerLinkTerms.href = localPage("terms");
      footerLinkContact.href = localPage("contact");
      footerLinkSitemap.href = localPage("sitemap");
    }

    function t(key, variables = {}) {
      const langPack = I18N[state.language] || I18N.ko;
      const fallback = I18N.ko[key] || key;
      const template = langPack[key] || fallback;
      return template.replace(/\{(\w+)\}/g, (_, token) => String(variables[token] ?? ""));
    }

    function getDitherName(mode) {
      if (mode === "ordered") return t("ditherNameOrdered");
      if (mode === "floyd") return t("ditherNameFloyd");
      return t("ditherNameNone");
    }

    function setPickedColorText(hex = "-") {
      pickedColor.textContent = `${t("pickedPrefix")}: ${hex}`;
    }

    function setPaletteCountText() {
      paletteCount.textContent = `${state.paletteColorCount} ${t("paletteColorsUnit")}`;
    }

    function applyLanguage() {
      document.documentElement.lang = state.language;
      document.title = t("pageTitle");

      heroSubtitle.textContent = t("heroSubtitle");
      heroLinkAbout.textContent = t("heroLinkAbout");
      heroLinkPrivacy.textContent = t("heroLinkPrivacy");
      heroLinkTerms.textContent = t("heroLinkTerms");
      heroLinkContact.textContent = t("heroLinkContact");
      heroLinkSitemap.textContent = t("heroLinkSitemap");
      applyLocalizedDocLinks();
      settingsTitle.textContent = t("settingsTitle");
      dropzoneLabel.textContent = t("dropzoneLabel");
      dropzoneHelp.textContent = t("dropzoneHelp");
      languageLabel.textContent = t("languageLabel");
      dotSizeLabelText.textContent = t("dotSizeLabel");
      colorLevelsLabelText.textContent = t("colorLevelsLabel");
      outputWidthLabelText.textContent = t("outputWidthLabel");
      dotShapeLabel.textContent = t("dotShapeLabel");
      ditherLabel.textContent = t("ditherLabel");
      fastModeLabel.textContent = t("fastModeLabel");
      fastModeDesc.textContent = t("fastModeDesc");
      convertButton.textContent = t("convertButton");
      downloadButton.textContent = t("downloadButton");
      resultTitle.textContent = t("resultTitle");
      compareLabel.textContent = t("compareLabel");
      compareTagBefore.textContent = t("compareTagBefore");
      compareTagAfter.textContent = t("compareTagAfter");
      paletteTitle.textContent = t("paletteTitle");
      tipText.textContent = t("tipText");
      footerSummary.textContent = t("footerSummary");
      footerLinkAbout.textContent = t("footerLinkAbout");
      footerLinkPrivacy.textContent = t("footerLinkPrivacy");
      footerLinkTerms.textContent = t("footerLinkTerms");
      footerLinkContact.textContent = t("footerLinkContact");
      footerLinkSitemap.textContent = t("footerLinkSitemap");

      const koOption = languageSelect.querySelector('option[value="ko"]');
      const enOption = languageSelect.querySelector('option[value="en"]');
      if (koOption) koOption.textContent = t("languageOptionKo");
      if (enOption) enOption.textContent = t("languageOptionEn");

      const shapeCircle = dotShape.querySelector('option[value="circle"]');
      const shapeSquare = dotShape.querySelector('option[value="square"]');
      if (shapeCircle) shapeCircle.textContent = t("dotShapeCircle");
      if (shapeSquare) shapeSquare.textContent = t("dotShapeSquare");

      const ditherNone = ditherMode.querySelector('option[value="none"]');
      const ditherOrdered = ditherMode.querySelector('option[value="ordered"]');
      const ditherFloyd = ditherMode.querySelector('option[value="floyd"]');
      if (ditherNone) ditherNone.textContent = t("ditherOptionNone");
      if (ditherOrdered) ditherOrdered.textContent = t("ditherOptionOrdered");
      if (ditherFloyd) ditherFloyd.textContent = t("ditherOptionFloyd");

      ditherInfoBtn.setAttribute("aria-label", t("ditherInfoAria"));
      ditherInfoTooltip.innerHTML = `${t("ditherTooltipNone")}<br />${t("ditherTooltipOrdered")}<br />${t("ditherTooltipFloyd")}`;

      updateControlLabels();
      setPickedColorText(state.selectedDot ? state.selectedDot.hex : "-");
      setPaletteCountText();
      const emptyNode = paletteGrid.querySelector(".palette-empty");
      if (emptyNode) {
        emptyNode.textContent = state.image ? t("paletteEmptyNone") : t("paletteEmptyBefore");
      }
    }

    function rgbToHex(r, g, b) {
      return `#${[r, g, b].map((v) => v.toString(16).padStart(2, "0")).join("")}`.toUpperCase();
    }

    function hexToRgb(hex) {
      const value = hex.replace("#", "");
      if (value.length !== 6) return null;
      return {
        r: Number.parseInt(value.slice(0, 2), 16),
        g: Number.parseInt(value.slice(2, 4), 16),
        b: Number.parseInt(value.slice(4, 6), 16),
      };
    }

    function getMarkerColorForHex(hex) {
      const rgb = hexToRgb(hex);
      if (!rgb) return "#FFFFFF";
      const luminance = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
      return luminance >= 160 ? "#111111" : "#FFFFFF";
    }

    function clearActiveSwatches() {
      paletteGrid.querySelectorAll(".swatch-item.active").forEach((node) => {
        node.classList.remove("active");
      });
    }

    function selectPaletteByHex(hex, shouldScroll = true) {
      clearActiveSwatches();
      const target = paletteGrid.querySelector(`.swatch-item[data-hex="${hex}"]`);
      if (target) {
        target.classList.add("active");
        if (shouldScroll) {
          target.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
      }
      setPickedColorText(hex);
    }

    function renderPalette(colorsWithCount, options = {}) {
      const { initial = false } = options;
      paletteGrid.innerHTML = "";
      state.paletteColorCount = colorsWithCount.length;
      setPickedColorText("-");
      setPaletteCountText();

      if (!colorsWithCount.length) {
        const empty = document.createElement("div");
        empty.className = "palette-empty";
        empty.textContent = initial ? t("paletteEmptyBefore") : t("paletteEmptyNone");
        paletteGrid.appendChild(empty);
        return;
      }

      colorsWithCount.forEach(([hex]) => {
        const item = document.createElement("div");
        item.className = "swatch-item";
        item.dataset.hex = hex;

        const colorBlock = document.createElement("div");
        colorBlock.className = "swatch-color";
        colorBlock.style.backgroundColor = hex;
        item.appendChild(colorBlock);

        const code = document.createElement("div");
        code.className = "swatch-code";
        code.textContent = hex;
        item.appendChild(code);

        paletteGrid.appendChild(item);
      });
    }

    function updateControlLabels() {
      dotSizeValue.textContent = `${dotSize.value}px`;
      colorLevelsValue.textContent = `${colorLevels.value}${t("colorLevelsUnit")}`;
      outputWidthValue.textContent = `${outputWidth.value}px`;
    }

    function setStatus(text) {
      statusText.textContent = text;
    }

    function baseName(name) {
      return name.replace(/\.[^.]+$/, "") || "dot-photo";
    }

    function quantizeChannel(value, levels) {
      if (levels <= 1) return value;
      const step = 255 / (levels - 1);
      return Math.round(value / step) * step;
    }

    function getQuantizeLut(levels) {
      const lut = new Uint8ClampedArray(256);
      for (let i = 0; i < 256; i += 1) {
        lut[i] = quantizeChannel(i, levels);
      }
      return lut;
    }

    function clampByte(value) {
      if (value < 0) return 0;
      if (value > 255) return 255;
      return value;
    }

    function updateCompareMask() {
      const percent = Number(compareSlider.value);
      const rightInset = 100 - percent;
      compareValue.textContent = `${percent}%`;
      resultCanvas.style.clipPath = `inset(0 ${rightInset}% 0 0)`;
      selectionCanvas.style.clipPath = `inset(0 ${rightInset}% 0 0)`;
      compareDivider.style.left = `${percent}%`;
    }

    function quantizeImageData(data, width, height, levels, mode) {
      const lut = getQuantizeLut(levels);

      if (mode === "none") {
        for (let i = 0; i < data.length; i += 4) {
          if (data[i + 3] <= 8) continue;
          data[i] = lut[data[i]];
          data[i + 1] = lut[data[i + 1]];
          data[i + 2] = lut[data[i + 2]];
        }
        return;
      }

      if (mode === "ordered") {
        const bayer4 = [
          [0, 8, 2, 10],
          [12, 4, 14, 6],
          [3, 11, 1, 9],
          [15, 7, 13, 5],
        ];
        const step = levels <= 1 ? 255 : 255 / (levels - 1);
        const scale = step * 0.55;

        for (let y = 0; y < height; y += 1) {
          for (let x = 0; x < width; x += 1) {
            const idx = (y * width + x) * 4;
            if (data[idx + 3] <= 8) continue;
            const threshold = (bayer4[y & 3][x & 3] - 7.5) / 16;
            const r = clampByte(Math.round(data[idx] + threshold * scale));
            const g = clampByte(Math.round(data[idx + 1] + threshold * scale));
            const b = clampByte(Math.round(data[idx + 2] + threshold * scale));
            data[idx] = lut[r];
            data[idx + 1] = lut[g];
            data[idx + 2] = lut[b];
          }
        }
        return;
      }

      // Floyd-Steinberg error diffusion
      const size = width * height;
      const rb = new Float32Array(size);
      const gb = new Float32Array(size);
      const bb = new Float32Array(size);
      const ab = new Uint8ClampedArray(size);

      for (let i = 0, p = 0; p < size; p += 1, i += 4) {
        rb[p] = data[i];
        gb[p] = data[i + 1];
        bb[p] = data[i + 2];
        ab[p] = data[i + 3];
      }

      const diffuse = (arr, index, err, weight) => {
        arr[index] += err * weight;
      };

      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const p = y * width + x;
          if (ab[p] <= 8) continue;

          const oldR = rb[p];
          const oldG = gb[p];
          const oldB = bb[p];

          const newR = lut[clampByte(Math.round(oldR))];
          const newG = lut[clampByte(Math.round(oldG))];
          const newB = lut[clampByte(Math.round(oldB))];

          rb[p] = newR;
          gb[p] = newG;
          bb[p] = newB;

          const errR = oldR - newR;
          const errG = oldG - newG;
          const errB = oldB - newB;

          if (x + 1 < width) {
            const p1 = p + 1;
            diffuse(rb, p1, errR, 7 / 16);
            diffuse(gb, p1, errG, 7 / 16);
            diffuse(bb, p1, errB, 7 / 16);
          }
          if (y + 1 < height) {
            const pDown = p + width;
            diffuse(rb, pDown, errR, 5 / 16);
            diffuse(gb, pDown, errG, 5 / 16);
            diffuse(bb, pDown, errB, 5 / 16);

            if (x > 0) {
              const pDownLeft = p + width - 1;
              diffuse(rb, pDownLeft, errR, 3 / 16);
              diffuse(gb, pDownLeft, errG, 3 / 16);
              diffuse(bb, pDownLeft, errB, 3 / 16);
            }
            if (x + 1 < width) {
              const pDownRight = p + width + 1;
              diffuse(rb, pDownRight, errR, 1 / 16);
              diffuse(gb, pDownRight, errG, 1 / 16);
              diffuse(bb, pDownRight, errB, 1 / 16);
            }
          }
        }
      }

      for (let i = 0, p = 0; p < size; p += 1, i += 4) {
        data[i] = lut[clampByte(Math.round(rb[p]))];
        data[i + 1] = lut[clampByte(Math.round(gb[p]))];
        data[i + 2] = lut[clampByte(Math.round(bb[p]))];
      }
    }

    function clearCanvasWithMessage(message) {
      originalCanvas.width = 720;
      originalCanvas.height = 480;
      resultCanvas.width = 720;
      resultCanvas.height = 480;
      selectionCanvas.width = 720;
      selectionCanvas.height = 480;

      originalCtx.fillStyle = "#121923";
      originalCtx.fillRect(0, 0, originalCanvas.width, originalCanvas.height);
      resultCtx.fillStyle = "#121923";
      resultCtx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
      resultCtx.fillStyle = "#8aa2bc";
      resultCtx.font = "600 20px SUIT, Pretendard, sans-serif";
      resultCtx.textAlign = "center";
      resultCtx.fillText(message, resultCanvas.width / 2, resultCanvas.height / 2);
      updateCompareMask();
      state.dotHexGrid = [];
      state.dotCols = 0;
      state.dotRows = 0;
      state.dotCellSize = 0;
      state.dotRadius = 0;
      state.selectedDot = null;
      renderPalette([], { initial: !state.image });
    }

    function drawSelectedDotMarker() {
      selectionCanvas.width = resultCanvas.width;
      selectionCanvas.height = resultCanvas.height;
      selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

      if (!state.selectedDot || !state.dotCellSize) return;

      const { col, row, hex } = state.selectedDot;
      if (col < 0 || row < 0 || col >= state.dotCols || row >= state.dotRows) return;

      const x = col * state.dotCellSize;
      const y = row * state.dotCellSize;
      const centerX = x + state.dotCellSize / 2;
      const centerY = y + state.dotCellSize / 2;
      const markerColor = getMarkerColorForHex(hex || "");
      const haloColor = markerColor === "#FFFFFF" ? "rgba(0, 0, 0, 0.45)" : "rgba(255, 255, 255, 0.45)";

      selectionCtx.save();
      selectionCtx.lineJoin = "round";

      if (state.dotShape === "circle") {
        const ringRadius = Math.max(state.dotCellSize * 0.52, state.dotRadius + Math.max(0.5, state.dotCellSize * 0.12));
        selectionCtx.strokeStyle = haloColor;
        selectionCtx.lineWidth = Math.max(1, state.dotCellSize * 0.2);
        selectionCtx.beginPath();
        selectionCtx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
        selectionCtx.stroke();

        selectionCtx.strokeStyle = markerColor;
        selectionCtx.lineWidth = Math.max(1, state.dotCellSize * 0.12);
        selectionCtx.beginPath();
        selectionCtx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
        selectionCtx.stroke();
      } else {
        const inset = state.dotCellSize <= 3 ? 0 : Math.max(0.5, state.dotCellSize * 0.08);
        const size = Math.max(1, state.dotCellSize - inset * 2);

        selectionCtx.strokeStyle = haloColor;
        selectionCtx.lineWidth = Math.max(1, state.dotCellSize * 0.2);
        selectionCtx.strokeRect(x + inset, y + inset, size, size);

        selectionCtx.strokeStyle = markerColor;
        selectionCtx.lineWidth = Math.max(1, state.dotCellSize * 0.12);
        selectionCtx.strokeRect(x + inset, y + inset, size, size);
      }

      selectionCtx.restore();
    }

    function renderDotArt() {
      if (!state.image) {
        clearCanvasWithMessage(t("canvasMessageSelect"));
        return;
      }

      const cellSize = Number(dotSize.value);
      const levels = Number(colorLevels.value);
      const requestedWidth = Number(outputWidth.value);
      let targetWidth = requestedWidth;
      const fastNotes = [];
      const requestedDither = ditherMode.value;
      let effectiveDither = requestedDither;

      if (fastModeToggle.checked && cellSize <= 2) {
        const widthCap = cellSize === 1 ? 900 : 1200;
        if (targetWidth > widthCap) {
          targetWidth = widthCap;
          fastNotes.push(t("noticeWidthCap", { width: widthCap }));
        }
      }

      if (fastModeToggle.checked && cellSize <= 2 && requestedDither === "floyd") {
        effectiveDither = "ordered";
        fastNotes.push(t("noticeDitherDowngrade"));
      }

      const ratio = state.image.height / state.image.width;
      const targetHeight = Math.max(cellSize, Math.round(targetWidth * ratio));

      const cols = Math.max(1, Math.floor(targetWidth / cellSize));
      const rows = Math.max(1, Math.floor(targetHeight / cellSize));

      sampleCanvas.width = cols;
      sampleCanvas.height = rows;
      sampleCtx.clearRect(0, 0, cols, rows);
      sampleCtx.imageSmoothingEnabled = true;
      sampleCtx.drawImage(state.image, 0, 0, cols, rows);

      const imageData = sampleCtx.getImageData(0, 0, cols, rows);
      const data = imageData.data;
      const colorCounter = new Map();
      const dotHexGrid = new Array(cols * rows).fill(null);
      quantizeImageData(data, cols, rows, levels, effectiveDither);

      for (let i = 0; i < data.length; i += 4) {
        const gridIndex = i / 4;
        if (data[i + 3] > 8) {
          const hex = rgbToHex(data[i], data[i + 1], data[i + 2]);
          dotHexGrid[gridIndex] = hex;
          colorCounter.set(hex, (colorCounter.get(hex) || 0) + 1);
        }
      }

      const sortedColors = [...colorCounter.entries()].sort((a, b) => b[1] - a[1]);
      renderPalette(sortedColors);

      resultCanvas.width = cols * cellSize;
      resultCanvas.height = rows * cellSize;
      originalCanvas.width = resultCanvas.width;
      originalCanvas.height = resultCanvas.height;
      selectionCanvas.width = resultCanvas.width;
      selectionCanvas.height = resultCanvas.height;

      originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
      originalCtx.imageSmoothingEnabled = true;
      originalCtx.drawImage(state.image, 0, 0, originalCanvas.width, originalCanvas.height);

      resultCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
      resultCtx.fillStyle = "#101722";
      resultCtx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
      updateCompareMask();

      const requestedShape = dotShape.value;
      // 1~2px에서는 원형 도트가 거의 보이지 않으므로 사각 렌더링으로 자동 폴백.
      const effectiveShape = requestedShape === "circle" && cellSize <= 2 ? "square" : requestedShape;

      if (effectiveShape === "square") {
        sampleCtx.putImageData(imageData, 0, 0);
        resultCtx.imageSmoothingEnabled = false;
        resultCtx.drawImage(sampleCanvas, 0, 0, cols, rows, 0, 0, resultCanvas.width, resultCanvas.height);
      } else {
        const radius = cellSize * 0.44;
        for (let y = 0; y < rows; y += 1) {
          for (let x = 0; x < cols; x += 1) {
            const idx = (y * cols + x) * 4;
            const alpha = data[idx + 3] / 255;
            if (alpha < 0.05) continue;
            resultCtx.fillStyle = `rgba(${data[idx]}, ${data[idx + 1]}, ${data[idx + 2]}, ${alpha.toFixed(3)})`;
            resultCtx.beginPath();
            resultCtx.arc(
              x * cellSize + cellSize / 2,
              y * cellSize + cellSize / 2,
              radius,
              0,
              Math.PI * 2
            );
            resultCtx.fill();
          }
        }
      }

      state.dotHexGrid = dotHexGrid;
      state.dotCols = cols;
      state.dotRows = rows;
      state.dotCellSize = cellSize;
      state.dotShape = effectiveShape;
      state.dotRadius = effectiveShape === "circle" ? cellSize * 0.44 : 0;

      if (state.selectedDot) {
        const { col, row } = state.selectedDot;
        if (col >= 0 && row >= 0 && col < cols && row < rows) {
          const selectedHex = state.dotHexGrid[row * cols + col];
          if (selectedHex) {
            state.selectedDot.hex = selectedHex;
            selectPaletteByHex(selectedHex, false);
          } else {
            state.selectedDot = null;
            setPickedColorText("-");
          }
        } else {
          state.selectedDot = null;
          setPickedColorText("-");
        }
      }

      drawSelectedDotMarker();

      dotInfo.textContent = t("dotInfoFormat", {
        cols,
        rows,
        dither: getDitherName(effectiveDither),
      });

      const notices = [];
      if (requestedShape === "circle" && effectiveShape === "square") {
        notices.push(t("noticeCircleFallback"));
      }
      if (fastNotes.length) {
        notices.push(`${t("noticeFastPrefix")}: ${fastNotes.join(", ")}`);
      }
      if (notices.length) {
        setStatus(t("statusCompleteWithNotices", { notices: notices.join(" / ") }));
      } else {
        setStatus(t("statusComplete"));
      }

      downloadButton.disabled = false;
    }

    function scheduleRender(delayMs = 90) {
      if (!state.image) return;
      if (state.renderTimer) {
        clearTimeout(state.renderTimer);
      }
      state.renderTimer = setTimeout(() => {
        state.renderTimer = null;
        renderDotArt();
      }, delayMs);
    }

    function handleCanvasPick(event) {
      if (!state.image || !state.dotHexGrid.length || !state.dotCellSize) return;

      const rect = resultCanvas.getBoundingClientRect();
      if (!rect.width || !rect.height) return;

      const visiblePercent = Number(compareSlider.value) / 100;
      const relativePercent = (event.clientX - rect.left) / rect.width;
      if (relativePercent > visiblePercent) {
        setStatus(t("statusClickAfter"));
        return;
      }

      const px = (event.clientX - rect.left) * (resultCanvas.width / rect.width);
      const py = (event.clientY - rect.top) * (resultCanvas.height / rect.height);

      if (px < 0 || py < 0 || px >= resultCanvas.width || py >= resultCanvas.height) return;

      const col = Math.floor(px / state.dotCellSize);
      const row = Math.floor(py / state.dotCellSize);
      if (col < 0 || row < 0 || col >= state.dotCols || row >= state.dotRows) return;

      if (state.dotShape === "circle") {
        const localX = px - col * state.dotCellSize;
        const localY = py - row * state.dotCellSize;
        const dx = localX - state.dotCellSize / 2;
        const dy = localY - state.dotCellSize / 2;
        if (Math.hypot(dx, dy) > state.dotRadius) {
          setStatus(t("statusClickCircle"));
          return;
        }
      }

      const hex = state.dotHexGrid[row * state.dotCols + col];
      if (!hex) {
        setStatus(t("statusNoColor"));
        return;
      }

      state.selectedDot = { col, row, hex };
      drawSelectedDotMarker();
      selectPaletteByHex(hex);
      setStatus(t("statusSelectedDot", { hex }));
    }

    function loadImage(file) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          state.image = img;
          state.fileName = baseName(file.name);
          convertButton.disabled = false;
          setStatus(t("statusLoadDone", { name: file.name }));
          renderDotArt();
        };
        img.onerror = () => {
          setStatus(t("statusImageReadError"));
        };
        img.src = reader.result;
      };
      reader.onerror = () => {
        setStatus(t("statusFileReadError"));
      };
      reader.readAsDataURL(file);
    }

    function handleFileList(fileList) {
      const [file] = fileList;
      if (!file) return;
      if (!file.type.startsWith("image/")) {
        setStatus(t("statusImageOnly"));
        return;
      }
      loadImage(file);
    }

    fileInput.addEventListener("change", (event) => {
      handleFileList(event.target.files);
    });

    dropzone.addEventListener("dragover", (event) => {
      event.preventDefault();
      dropzone.classList.add("dragging");
    });

    dropzone.addEventListener("dragleave", () => {
      dropzone.classList.remove("dragging");
    });

    dropzone.addEventListener("drop", (event) => {
      event.preventDefault();
      dropzone.classList.remove("dragging");
      handleFileList(event.dataTransfer.files);
    });

    resultCanvas.addEventListener("click", handleCanvasPick);

    paletteGrid.addEventListener("click", (event) => {
      const target = event.target.closest(".swatch-item");
      if (!target) return;
      const hex = target.dataset.hex;
      if (!hex) return;
      selectPaletteByHex(hex, false);
      setStatus(t("statusSelectedPalette", { hex }));
    });

    languageSelect.addEventListener("change", () => {
      state.language = normalizeLanguage(languageSelect.value);
      localStorage.setItem("dotphoto-language", state.language);
      updateLanguageQuery();
      applyLanguage();
      if (state.image) {
        renderDotArt();
      } else {
        clearCanvasWithMessage(t("canvasMessageInit"));
        dotInfo.textContent = "-";
        setStatus(t("statusSelectFirst"));
      }
    });

    [dotSize, colorLevels, outputWidth, dotShape, ditherMode].forEach((control) => {
      const rerender = () => {
        updateControlLabels();
        scheduleRender(100);
      };
      control.addEventListener("input", rerender);
      control.addEventListener("change", rerender);
    });

    fastModeToggle.addEventListener("change", () => {
      scheduleRender(50);
    });

    ditherInfoBtn.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen = ditherInfoWrap.classList.toggle("open");
      ditherInfoBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
    });

    document.addEventListener("click", (event) => {
      if (!ditherInfoWrap.contains(event.target)) {
        ditherInfoWrap.classList.remove("open");
        ditherInfoBtn.setAttribute("aria-expanded", "false");
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        ditherInfoWrap.classList.remove("open");
        ditherInfoBtn.setAttribute("aria-expanded", "false");
      }
    });

    compareSlider.addEventListener("input", () => {
      updateCompareMask();
    });

    convertButton.addEventListener("click", () => {
      renderDotArt();
    });

    downloadButton.addEventListener("click", () => {
      const link = document.createElement("a");
      link.href = resultCanvas.toDataURL("image/png");
      link.download = `${state.fileName}-dot.png`;
      link.click();
    });

    const savedLanguage = localStorage.getItem("dotphoto-language");
    const urlLanguage = getLanguageFromUrl();
    const browserLanguage = (navigator.language || "ko").toLowerCase();
    const autoLanguage = browserLanguage.startsWith("ko") ? "ko" : "en";
    state.language = normalizeLanguage(urlLanguage || savedLanguage || autoLanguage);
    languageSelect.value = state.language;
    updateLanguageQuery();
    applyLanguage();
    updateCompareMask();
    clearCanvasWithMessage(t("canvasMessageInit"));
    setStatus(t("statusSelectFirst"));
  </script>
</body>
</html>
