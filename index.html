<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>사주 분석기</title>
  <style>
    :root {
      --bg: #f4efe6;
      --card: #fffaf0;
      --text: #1f1a14;
      --accent: #8a4b08;
      --accent-2: #c67a24;
      --line: #e2d6c2;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Noto Sans KR", "Apple SD Gothic Neo", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 20% 0%, #fff5db 0%, transparent 35%),
        radial-gradient(circle at 80% 100%, #ffe5c5 0%, transparent 30%),
        var(--bg);
      min-height: 100vh;
      padding: 24px;
    }

    .container {
      max-width: 980px;
      margin: 0 auto;
      display: grid;
      gap: 18px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 10px 26px rgba(72, 40, 6, 0.08);
    }

    h1 {
      margin: 0 0 8px;
      font-size: 1.8rem;
    }

    p.lead {
      margin: 0;
      color: #59452d;
    }

    form {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    label {
      display: grid;
      gap: 6px;
      font-size: 0.93rem;
      font-weight: 600;
    }

    input, select, button {
      font: inherit;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #cfbeaa;
      background: #fff;
      color: var(--text);
    }

    .row {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .row input[type="checkbox"] { width: 16px; height: 16px; }

    button {
      border: 0;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.15s ease;
      padding: 12px 16px;
    }

    button:hover { transform: translateY(-1px); }

    .full { grid-column: 1 / -1; }

    .pillars {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .pillar {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      background: #fff;
      text-align: center;
    }

    .pillar .k {
      font-size: 0.82rem;
      color: #7a6248;
      margin-bottom: 6px;
    }

    .pillar .v {
      font-size: 1.3rem;
      font-weight: 800;
    }

    .analysis {
      margin-top: 12px;
      display: grid;
      gap: 8px;
    }

    .notice {
      color: #734d20;
      font-size: 0.9rem;
      margin-top: 4px;
    }

    @media (max-width: 760px) {
      form { grid-template-columns: 1fr; }
      .pillars { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
  </style>
</head>
<body>
  <div class="container">
    <section class="card">
      <h1>사주 분석기</h1>
      <p class="lead">생년월일/시간과 음력·양력 구분을 입력하면 사주(년주·월주·일주·시주)와 간단한 해석을 제공합니다.</p>
    </section>

    <section class="card">
      <form id="sajuForm">
        <label>
          달력 구분
          <select id="calendarType">
            <option value="solar">양력</option>
            <option value="lunar">음력</option>
          </select>
        </label>

        <label>
          출생 연도
          <input id="year" type="number" min="1900" max="2099" required />
        </label>

        <label>
          출생 월
          <input id="month" type="number" min="1" max="12" required />
        </label>

        <label>
          출생 일
          <input id="day" type="number" min="1" max="31" required />
        </label>

        <label>
          출생 시 (0~23)
          <input id="hour" type="number" min="0" max="23" required />
        </label>

        <label>
          출생 분 (0~59)
          <input id="minute" type="number" min="0" max="59" value="0" required />
        </label>

        <label class="row" id="leapRow" style="display:none;">
          <input id="isLeapMonth" type="checkbox" />
          윤달(음력 윤월)입니다.
        </label>

        <div class="full">
          <button type="submit">사주 분석하기</button>
        </div>
      </form>
      <div class="notice" id="notice"></div>
    </section>

    <section class="card" id="result" style="display:none;">
      <h2>분석 결과</h2>
      <div id="convertedDate"></div>
      <div class="pillars" id="pillars"></div>
      <div class="analysis" id="analysis"></div>
    </section>
  </div>

  <script>
    const STEMS = ["갑", "을", "병", "정", "무", "기", "경", "신", "임", "계"];
    const BRANCHES = ["자", "축", "인", "묘", "진", "사", "오", "미", "신", "유", "술", "해"];

    const STEM_ELEMENTS = ["목", "목", "화", "화", "토", "토", "금", "금", "수", "수"];
    const BRANCH_ELEMENTS = ["수", "토", "목", "목", "토", "화", "화", "토", "금", "금", "토", "수"];

    const dayMs = 24 * 60 * 60 * 1000;
    const TZ = "Asia/Seoul";

    const lunarFormatter = new Intl.DateTimeFormat("en-US-u-ca-chinese", {
      timeZone: TZ,
      year: "numeric",
      month: "numeric",
      day: "numeric",
    });

    const ymdFormatter = new Intl.DateTimeFormat("en-CA", {
      timeZone: TZ,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
      hourCycle: "h23",
    });

    function mod(n, m) {
      return ((n % m) + m) % m;
    }

    function makeKstDate(y, m, d, h = 0, min = 0) {
      return new Date(Date.UTC(y, m - 1, d, h - 9, min, 0));
    }

    function getKstParts(date) {
      const parts = ymdFormatter.formatToParts(date);
      const pick = (type) => Number(parts.find((p) => p.type === type)?.value || 0);
      return {
        year: pick("year"),
        month: pick("month"),
        day: pick("day"),
        hour: pick("hour"),
        minute: pick("minute"),
      };
    }

    function parseLunarParts(date) {
      const parts = lunarFormatter.formatToParts(date);
      const yearRaw = parts.find((p) => p.type === "relatedYear")?.value || parts.find((p) => p.type === "year")?.value || "";
      const monthRaw = parts.find((p) => p.type === "month")?.value || "";
      const dayRaw = parts.find((p) => p.type === "day")?.value || "";

      const yearNum = Number((yearRaw.match(/\d+/) || [""])[0]);
      const monthNum = Number((monthRaw.match(/\d+/) || [""])[0]);
      const dayNum = Number((dayRaw.match(/\d+/) || [""])[0]);
      const isLeap = /윤|leap|bis/i.test(monthRaw);

      return {
        year: yearNum,
        month: monthNum,
        day: dayNum,
        isLeap,
      };
    }

    function isValidSolarInput(y, m, d, h, min) {
      if (m < 1 || m > 12 || d < 1 || d > 31 || h < 0 || h > 23 || min < 0 || min > 59) return false;
      const dt = makeKstDate(y, m, d, h, min);
      const p = getKstParts(dt);
      return p.year === y && p.month === m && p.day === d && p.hour === h && p.minute === min;
    }

    function lunarToSolar(lYear, lMonth, lDay, isLeap, hour, minute) {
      const start = makeKstDate(lYear - 1, 1, 1, 0, 0).getTime();
      const end = makeKstDate(lYear + 1, 12, 31, 0, 0).getTime();

      for (let t = start; t <= end; t += dayMs) {
        const d = new Date(t);
        const lunar = parseLunarParts(d);
        if (
          lunar.year === lYear &&
          lunar.month === lMonth &&
          lunar.day === lDay &&
          lunar.isLeap === isLeap
        ) {
          const kst = getKstParts(d);
          return makeKstDate(kst.year, kst.month, kst.day, hour, minute);
        }
      }
      return null;
    }

    function getYearPillar(kstDate) {
      const { year, month, day } = getKstParts(kstDate);
      let sajuYear = year;

      // 입춘(대략 2월 4일) 이전은 전년도 간지 사용
      if (month < 2 || (month === 2 && day < 4)) sajuYear -= 1;

      const stemIdx = mod(sajuYear - 4, 10);
      const branchIdx = mod(sajuYear - 4, 12);
      return { stemIdx, branchIdx, text: STEMS[stemIdx] + BRANCHES[branchIdx] };
    }

    function getSajuMonthOrder(kstDate) {
      const { year, month, day } = getKstParts(kstDate);
      const md = month * 100 + day;

      // 절입 기준 단순화: 각 월의 주요 절기 경계일
      if (md >= 204 && md < 306) return 1;   // 寅
      if (md >= 306 && md < 405) return 2;   // 卯
      if (md >= 405 && md < 506) return 3;   // 辰
      if (md >= 506 && md < 606) return 4;   // 巳
      if (md >= 606 && md < 707) return 5;   // 午
      if (md >= 707 && md < 808) return 6;   // 未
      if (md >= 808 && md < 908) return 7;   // 申
      if (md >= 908 && md < 1008) return 8;  // 酉
      if (md >= 1008 && md < 1107) return 9; // 戌
      if (md >= 1107 && md < 1207) return 10;// 亥
      if (md >= 1207 || md < 106) return 11; // 子
      return 12;                               // 丑 (1/6~2/3)
    }

    function getMonthPillar(kstDate, yearStemIdx) {
      const monthOrder = getSajuMonthOrder(kstDate); // 1~12 (寅~丑)
      const stemIdx = mod(yearStemIdx * 2 + monthOrder + 1, 10);
      const branchIdx = mod(monthOrder + 1, 12);
      return { stemIdx, branchIdx, text: STEMS[stemIdx] + BRANCHES[branchIdx] };
    }

    function getDayPillar(kstDate) {
      // 기준일: 1984-02-02 (갑자일)
      const base = makeKstDate(1984, 2, 2, 0, 0);
      const current = makeKstDate(getKstParts(kstDate).year, getKstParts(kstDate).month, getKstParts(kstDate).day, 0, 0);
      const diffDays = Math.floor((current.getTime() - base.getTime()) / dayMs);
      const cycle = mod(diffDays, 60);
      const stemIdx = mod(cycle, 10);
      const branchIdx = mod(cycle, 12);
      return { stemIdx, branchIdx, text: STEMS[stemIdx] + BRANCHES[branchIdx] };
    }

    function getHourPillar(kstDate, dayStemIdx) {
      const { hour } = getKstParts(kstDate);
      const branchIdx = mod(Math.floor((hour + 1) / 2), 12);
      const stemIdx = mod((dayStemIdx % 5) * 2 + branchIdx, 10);
      return { stemIdx, branchIdx, text: STEMS[stemIdx] + BRANCHES[branchIdx] };
    }

    function buildAnalysis(yearP, monthP, dayP, hourP) {
      const elements = {
        목: 0,
        화: 0,
        토: 0,
        금: 0,
        수: 0,
      };

      const pillars = [yearP, monthP, dayP, hourP];
      pillars.forEach((p) => {
        elements[STEM_ELEMENTS[p.stemIdx]] += 1;
        elements[BRANCH_ELEMENTS[p.branchIdx]] += 1;
      });

      const sorted = Object.entries(elements).sort((a, b) => b[1] - a[1]);
      const strongest = sorted[0][0];
      const weakest = sorted[sorted.length - 1][0];
      const dayMaster = STEM_ELEMENTS[dayP.stemIdx];

      const dayStemNature = {
        갑: "큰 나무처럼 곧고 추진력이 강한 성향",
        을: "덩굴처럼 유연하고 조율 능력이 좋은 성향",
        병: "태양처럼 밝고 표현력이 풍부한 성향",
        정: "촛불처럼 섬세하고 집중력이 좋은 성향",
        무: "산처럼 안정감 있고 책임감이 강한 성향",
        기: "논밭처럼 실용적이고 현실 감각이 좋은 성향",
        경: "원석처럼 결단력 있고 직선적인 성향",
        신: "보석처럼 정밀하고 미적 감각이 좋은 성향",
        임: "바다처럼 스케일이 크고 포용적인 성향",
        계: "비처럼 섬세하고 관찰력이 좋은 성향",
      };

      return {
        elements,
        summary1: `일간은 ${STEMS[dayP.stemIdx]}(${dayMaster})으로, ${dayStemNature[STEMS[dayP.stemIdx]]}입니다.`,
        summary2: `오행은 ${strongest} 기운이 강하고 ${weakest} 기운이 상대적으로 약하게 나타납니다.`,
        summary3: `${weakest} 성향(관련 활동/환경)을 의식적으로 보완하면 균형을 잡는 데 도움이 됩니다.`,
      };
    }

    function elementLine(elements) {
      return Object.entries(elements)
        .map(([k, v]) => `${k} ${v}`)
        .join(" · ");
    }

    function renderResult(solarDate, yearP, monthP, dayP, hourP, analysis) {
      const result = document.getElementById("result");
      const convertedDate = document.getElementById("convertedDate");
      const pillars = document.getElementById("pillars");
      const analysisBox = document.getElementById("analysis");

      const s = getKstParts(solarDate);
      convertedDate.innerHTML = `<strong>기준 양력 시각:</strong> ${s.year}-${String(s.month).padStart(2, "0")}-${String(s.day).padStart(2, "0")} ${String(s.hour).padStart(2, "0")}:${String(s.minute).padStart(2, "0")} (KST)`;

      pillars.innerHTML = "";
      [
        ["년주", yearP.text],
        ["월주", monthP.text],
        ["일주", dayP.text],
        ["시주", hourP.text],
      ].forEach(([k, v]) => {
        const div = document.createElement("div");
        div.className = "pillar";
        div.innerHTML = `<div class="k">${k}</div><div class="v">${v}</div>`;
        pillars.appendChild(div);
      });

      analysisBox.innerHTML = `
        <div><strong>오행 분포:</strong> ${elementLine(analysis.elements)}</div>
        <div>${analysis.summary1}</div>
        <div>${analysis.summary2}</div>
        <div>${analysis.summary3}</div>
        <div class="notice">참고: 본 결과는 전통 명리 계산을 단순화한 자동 해석으로, 전문가 감정과 차이가 있을 수 있습니다.</div>
      `;

      result.style.display = "block";
    }

    function showError(msg) {
      document.getElementById("notice").textContent = msg;
      document.getElementById("result").style.display = "none";
    }

    function clearNotice() {
      document.getElementById("notice").textContent = "";
    }

    document.getElementById("calendarType").addEventListener("change", (e) => {
      const isLunar = e.target.value === "lunar";
      document.getElementById("leapRow").style.display = isLunar ? "flex" : "none";
    });

    document.getElementById("sajuForm").addEventListener("submit", (e) => {
      e.preventDefault();
      clearNotice();

      const type = document.getElementById("calendarType").value;
      const year = Number(document.getElementById("year").value);
      const month = Number(document.getElementById("month").value);
      const day = Number(document.getElementById("day").value);
      const hour = Number(document.getElementById("hour").value);
      const minute = Number(document.getElementById("minute").value);
      const isLeap = document.getElementById("isLeapMonth").checked;

      if (!year || !isValidSolarInput(year, month, day, hour, minute)) {
        showError("입력값을 확인해 주세요.");
        return;
      }

      let solarDate = null;

      if (type === "solar") {
        solarDate = makeKstDate(year, month, day, hour, minute);
      } else {
        solarDate = lunarToSolar(year, month, day, isLeap, hour, minute);
        if (!solarDate) {
          showError("입력한 음력 날짜를 양력으로 변환하지 못했습니다. (브라우저 지원/윤달 여부 확인 필요)");
          return;
        }
      }

      const yearP = getYearPillar(solarDate);
      const monthP = getMonthPillar(solarDate, yearP.stemIdx);
      const dayP = getDayPillar(solarDate);
      const hourP = getHourPillar(solarDate, dayP.stemIdx);

      const analysis = buildAnalysis(yearP, monthP, dayP, hourP);
      renderResult(solarDate, yearP, monthP, dayP, hourP, analysis);
    });
  </script>
</body>
</html>
